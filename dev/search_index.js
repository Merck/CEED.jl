var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"CurrentModule = CEEDesigns","category":"page"},{"location":"api.html#StaticDesigns","page":"API Documentation","title":"StaticDesigns","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"CEEDesigns.StaticDesigns.efficient_designs\nCEEDesigns.StaticDesigns.evaluate_experiments","category":"page"},{"location":"api.html#CEEDesigns.StaticDesigns.efficient_designs","page":"API Documentation","title":"CEEDesigns.StaticDesigns.efficient_designs","text":"efficient_designs(experiments, evals; max_parallel=1, tradeoff=(1, 0), mdp_kwargs=default_mdp_kwargs)\n\nReturn the set of Pareto-efficient experimental designs, given experimental costs, predictive accuracy (loss), and estimated filtration rates for experimental subsets.\n\nArguments\n\nexperiments: a dictionary containing pairs experiment => cost (=> features), where cost can either be scalar cost or a tuple (monetary cost, execution time).\nevals: a dictionary containing pairs experimental subset => (; predictive loss, filtration).\n\nKeyword arguments\n\nparallel: to estimate the execution time of the design, define the number of experiments that can run concurrently. The experiments will subsequently be arranged in descending order based on their individual durations, and they will be then iteratively allocated into consecutive groups that represent parallel experiments.\ntradeoff: determines how to project the monetary cost and execution time of an experimental design onto a single combined cost.\n\nExample\n\nefficient_designs(\n    experiments_costs,\n    model,\n    data[!, Not(\"HeartDisease\")],\n    data[!, \"HeartDisease\"];\n    eval_options = (; zero_cost_features, measure = LogLoss()),\n    arrangement_options = (; max_parallel = 2, tradeoff = (0.0, 1)),\n)\n\n\n\n\n\nefficient_designs(experiments, args...; eval_options, arrangement_options)\n\nEvaluate predictive power for subsets of experiments, and return the set of Pareto-efficient experimental designs.\n\nInternally, evaluate_experiments is called first, followed by efficient_designs.\n\nKeyword arguments\n\neval_options: keyword arguments to evaluate_experiments.\narrangement_options: keyword arguments to efficient_designs.\n\nExample\n\nefficient_designs(\n    experiments_costs,\n    data_binary;\n    eval_options = (; zero_cost_features),\n    arrangement_options = (; max_parallel = 2, tradeoff = (0.0, 1)),\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#CEEDesigns.StaticDesigns.evaluate_experiments","page":"API Documentation","title":"CEEDesigns.StaticDesigns.evaluate_experiments","text":"evaluate_experiments(experiments, model, X, y; zero_cost_features=[], evaluate_empty_subset=true, return_full_metrics=false, kwargs...)\n\nEvaluate predictive accuracy over subsets of experiments, and return the metrics. The evaluation is facilitated by MLJ.evaluate; additional keyword arguments to this function will be passed to evaluate.\n\nEvaluations are run in parallel.\n\nArguments\n\nexperiments: a dictionary containing pairs experiment => (cost =>) features, where features is a subset of column names in data.\nmodel: a predictive model whose accuracy will be evaluated.\nX: a dataframe with features used for prediction.\ny: the variable that we aim to predict.\n\nKeyword arguments\n\nmax_cardinality: maximum cardinality of experimental subsets (defaults to the number of experiments).\nzero_cost_features: additional zero-cost features available for each experimental subset (defaults to an empty list).\nevaluate_empty_subset: flag indicating whether to evaluate empty experimental subset. A constant column will be added if zero_cost_features is empty (defaults to true).\nreturn_full_metrics: flag indicating whether to return full MLJ.PerformanceEvaluation metrics. Otherwise return an aggregate \"measurement\" for the first measure (defaults to false).\n\nExample\n\nevaluate_experiments(\n    experiments,\n    model,\n    data[!, Not(\"HeartDisease\")],\n    data[!, \"HeartDisease\"];\n    zero_cost_features,\n    measure = LogLoss(),\n)\n\n\n\n\n\nevaluate_experiments(experiments, X; zero_cost_features=[], evaluate_empty_subset=true)\n\nEvaluate discriminative power for subsets of experiments, and return the metrics.\n\nEvaluations are run in parallel.\n\nArguments\n\nexperiments: a dictionary containing pairs experiment => (cost =>) features, where features is a subset of column names in X.\nX: a dataframe containing binary labels, where false indicated that an entity was filtered out by the experiment (and should be removed from the triage).\n\nKeyword arguments\n\nzero_cost_features: additional zero-cost features available for each experimental subset (defaults to an empty list).\nevaluate_empty_subset: flag indicating whether to evaluate empty experimental subset.\n\nExample\n\nevaluate_experiments(experiments, data_binary; zero_cost_features)\n\n\n\n\n\n","category":"function"},{"location":"api.html#GenerativeDesigns","page":"API Documentation","title":"GenerativeDesigns","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"CEEDesigns.GenerativeDesigns.UncertaintyReductionMDP\nCEEDesigns.GenerativeDesigns.EfficientValueMDP\nCEEDesigns.GenerativeDesigns.State\nCEEDesigns.GenerativeDesigns.Variance\nCEEDesigns.GenerativeDesigns.Entropy","category":"page"},{"location":"api.html#CEEDesigns.GenerativeDesigns.UncertaintyReductionMDP","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.UncertaintyReductionMDP","text":"UncertaintyReductionMDP(costs; sampler, uncertainty, threshold, evidence=Evidence(), <keyword arguments>)\n\nStructure that parametrizes the experimental decision-making process. It is used in the object interface of POMDPs.\n\nIn this experimental setup, our objective is to minimize the expected experimental cost while ensuring the uncertainty remains below a specified threshold.\n\nInternally, a state of the decision process is modeled as a tuple (evidence::Evidence, [total accumulated monetary cost, total accumulated execution time]).\n\nArguments\n\ncosts: a dictionary containing pairs experiment => cost, where cost can either be a scalar cost (modelled as a monetary cost) or a tuple (monetary cost, execution time).\n\nKeyword Arguments\n\nsampler: a function of (evidence, features, rng), in which evidence denotes the current experimental evidence, features represent the set of features we want to sample from, and rng is a random number generator; it returns a dictionary mapping the features to outcomes.\nuncertainty: a function of evidence; it returns the measure of variance or uncertainty about the target variable, conditioned on the experimental evidence acquired so far.\nthreshold: a number representing the acceptable level of uncertainty about the target variable.\nevidence=Evidence(): initial experimental evidence.\ncosts_tradeoff: tradeoff between monetary cost and execution time of an experimental designs, given as a tuple of floats.\nmax_parallel: maximum number of parallel experiments.\ndiscount: this is the discounting factor utilized in reward computation.\nbigM: it refers to the penalty that arises in a scenario where further experimental action is not an option, yet the uncertainty exceeds the allowable limit.\nmax_experiments: this denotes the maximum number of experiments that are permissible to be conducted.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CEEDesigns.GenerativeDesigns.EfficientValueMDP","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.EfficientValueMDP","text":"EfficientValueMDP(costs; sampler, value, evidence=Evidence(), <keyword arguments>)\n\nStructure that parametrizes the experimental decision-making process. It is used in the object interface of POMDPs.\n\nIn this experimental setup, our objective is to maximize the value of the experimental evidence (such as clinical utility), adjusted for experimental costs.\n\nInternally, the reward associated with a particular experimental evidence and with total accumulated monetary_cost and (optionally) execution_time is computed as value(evidence) - costs_tradeoff' * [monetary_cost, execution_time].\n\nArguments\n\ncosts: a dictionary containing pairs experiment => cost, where cost can either be a scalar cost (modelled as a monetary cost) or a tuple (monetary cost, execution time).\n\nKeyword Arguments\n\nsampler: a function of (evidence, features, rng), in which evidence denotes the current experimental evidence, features represent the set of features we want to sample from, and rng is a random number generator; it returns a dictionary mapping the features to outcomes.\nvalue: a function of (evidence); it quantifies the utility of experimental evidence.\nevidence=Evidence(): initial experimental evidence.\nmax_parallel: maximum number of parallel experiments.\ndiscount: this is the discounting factor utilized in reward computation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CEEDesigns.GenerativeDesigns.State","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.State","text":"Represent experimental state as a tuple of experimental costs and evidence.\n\n\n\n\n\n","category":"type"},{"location":"api.html#CEEDesigns.GenerativeDesigns.Variance","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.Variance","text":"Variance(data; prior)\n\nReturn a function of weights that computes the fraction of variance in the data, relative to the variance calculated with respect to a specified prior.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CEEDesigns.GenerativeDesigns.Entropy","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.Entropy","text":"Entropy(labels; prior)\n\nReturn a function of weights that computes the fraction of information entropy, relative to the entropy calculated with respect to a specified prior.\n\n\n\n\n\n","category":"function"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"CEEDesigns.GenerativeDesigns.efficient_design\nCEEDesigns.GenerativeDesigns.efficient_designs\nCEEDesigns.GenerativeDesigns.efficient_value","category":"page"},{"location":"api.html#CEEDesigns.GenerativeDesigns.efficient_design","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.efficient_design","text":"efficient_design(costs; sampler, uncertainty, threshold, evidence=Evidence(), <keyword arguments>)\n\nIn the uncertainty reduction setup, minimize the expected experimental cost while ensuring the uncertainty remains below a specified threshold.\n\nArguments\n\ncosts: a dictionary containing pairs experiment => cost, where cost can either be a scalar cost (modelled as a monetary cost) or a tuple (monetary cost, execution time).\n\nKeyword Arguments\n\nsampler: a function of (evidence, features, rng), in which evidence denotes the current experimental evidence, features represent the set of features we want to sample from, and rng is a random number generator; it returns a dictionary mapping the features to outcomes.\nuncertainty: a function of evidence; it returns the measure of variance or uncertainty about the target variable, conditioned on the experimental evidence acquired so far.\nthreshold: uncertainty threshold.\nevidence=Evidence(): initial experimental evidence.\nsolver=default_solver: a POMDPs.jl compatible solver used to solve the decision process. The default solver is DPWSolver.\nrepetitions=0: number of runoffs used to estimate the expected experimental cost.\nmdp_options: a NamedTuple of additional keyword arguments that will be passed to the constructor of UncertaintyReductionMDP.\nrealized_uncertainty=false: whenever the initial state uncertainty is below the selected threshold, return the actual uncertainty of this state.\n\nExample\n\n(; sampler, uncertainty, weights) = DistanceBased(\n    data;\n    target = \"HeartDisease\",\n    uncertainty = Entropy,\n    similarity = Exponential(; λ = 5),\n);\n# initialize evidence\nevidence = Evidence(\"Age\" => 35, \"Sex\" => \"M\")\n# set up solver (or use default)\nsolver = GenerativeDesigns.DPWSolver(; n_iterations = 60_000, tree_in_info = true)\ndesigns = efficient_design(\n    costs;\n    experiments,\n    sampler,\n    uncertainty,\n    threshold = 0.6,\n    evidence,\n    solver,            # planner\n    mdp_options = (; max_parallel = 1),\n    repetitions = 5,\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#CEEDesigns.GenerativeDesigns.efficient_designs","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.efficient_designs","text":"efficient_designs(costs; sampler, uncertainty, thresholds, evidence=Evidence(), <keyword arguments>)\n\nIn the uncertainty reduction setup, minimize the expected experimental resource spend over a range of uncertainty thresholds, and return the set of Pareto-efficient designs in the dimension of cost and uncertainty threshold.\n\nInternally, an instance of the UncertaintyReductionMDP structure is created for every selected uncertainty threshold and the corresponding runoffs are simulated.\n\nArguments\n\ncosts: a dictionary containing pairs experiment => cost, where cost can either be a scalar cost (modelled as a monetary cost) or a tuple (monetary cost, execution time).\n\nKeyword Arguments\n\nsampler: a function of (evidence, features, rng), in which evidence denotes the current experimental evidence, features represent the set of features we want to sample from, and rng is a random number generator; it returns a dictionary mapping the features to outcomes.\nuncertainty: a function of evidence; it returns the measure of variance or uncertainty about the target variable, conditioned on the experimental evidence acquired so far.\nthresholds: number of thresholds to consider uniformly in the range between 0 and 1, inclusive.\nevidence=Evidence(): initial experimental evidence.\nsolver=default_solver: a POMDPs.jl compatible solver used to solve the decision process. The default solver is DPWSolver.\nrepetitions=0: number of runoffs used to estimate the expected experimental cost.\nmdp_options: a NamedTuple of additional keyword arguments that will be passed to the constructor of UncertaintyReductionMDP.\nrealized_uncertainty=false: whenever the initial state uncertainty is below the selected threshold, return the actual uncertainty of this state.\n\nExample\n\n(; sampler, uncertainty, weights) = DistanceBased(\n    data;\n    target = \"HeartDisease\",\n    uncertainty = Entropy,\n    similarity = Exponential(; λ = 5),\n);\n# initialize evidence\nevidence = Evidence(\"Age\" => 35, \"Sex\" => \"M\")\n# set up solver (or use default)\nsolver = GenerativeDesigns.DPWSolver(; n_iterations = 60_000, tree_in_info = true)\ndesigns = efficient_designs(\n    costs;\n    experiments,\n    sampler,\n    uncertainty,\n    thresholds = 6,\n    evidence,\n    solver,            # planner\n    mdp_options = (; max_parallel = 1),\n    repetitions = 5,\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#CEEDesigns.GenerativeDesigns.efficient_value","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.efficient_value","text":"efficient_value(costs; sampler, value, evidence=Evidence(), <keyword arguments>)\n\nEstimate the maximum value of experimental evidence (such as clinical utility), adjusted for experimental costs.\n\nInternally, an instance of the EfficientValueMDP structure is created and a summary over repetitions runoffs is returned.\n\nArguments\n\ncosts: a dictionary containing pairs experiment => cost, where cost can either be a scalar cost (modelled as a monetary cost) or a tuple (monetary cost, execution time).\n\nKeyword Arguments\n\nsampler: a function of (evidence, features, rng), in which evidence denotes the current experimental evidence, features represent the set of features we want to sample from, and rng is a random number generator; it returns a dictionary mapping the features to outcomes.\nvalue: a function of (evidence, (monetary costs, execution time)); it quantifies the utility of experimental evidence.\nevidence=Evidence(): initial experimental evidence.\nsolver=default_solver: a POMDPs.jl compatible solver used to solve the decision process. The default solver is DPWSolver.\nrepetitions=0: number of runoffs used to estimate the expected experimental cost.\nmdp_options: a NamedTuple of additional keyword arguments that will be passed to the constructor of EfficientValueMDP.\n\nExample\n\n(; sampler, uncertainty, weights) = DistanceBased(\n    data;\n    target = \"HeartDisease\",\n    uncertainty = Entropy,\n    similarity = Exponential(; λ = 5),\n);\nvalue = (evidence, costs) -> (1 - uncertainty(evidence) + 0.005 * sum(costs));\n# initialize evidence\nevidence = Evidence(\"Age\" => 35, \"Sex\" => \"M\")\n# set up solver (or use default)\nsolver =\n    GenerativeDesigns.DPWSolver(; n_iterations = 10_000, depth = 3, tree_in_info = true)\ndesign = efficient_value(\n    experiments;\n    sampler,\n    value,\n    evidence,\n    solver,            # planner\n    mdp_options = (; max_parallel = 1),\n    repetitions = 5,\n)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Distance-Based-Sampling","page":"API Documentation","title":"Distance-Based Sampling","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"CEEDesigns.GenerativeDesigns.DistanceBased\nCEEDesigns.GenerativeDesigns.QuadraticDistance\nCEEDesigns.GenerativeDesigns.DiscreteDistance\nCEEDesigns.GenerativeDesigns.MahalanobisDistance\nCEEDesigns.GenerativeDesigns.Exponential","category":"page"},{"location":"api.html#CEEDesigns.GenerativeDesigns.DistanceBased","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.DistanceBased","text":"DistanceBased(data; target, uncertainty=Entropy, similarity=Exponential(), distance=Dict(); prior=ones(nrow(data)))\n\nCompute distances between experimental evidence and historical readouts, and apply a 'similarity' functional to obtain probability mass for each row.\n\nConsider using QuadraticDistance, DiscreteDistance, and MahalanobisDistance.\n\nReturn value\n\nA named tuple with the following fields:\n\nsampler: a function of (evidence, features, rng), in which evidence denotes the current experimental evidence, features represent the set of features we want to sample from, and rng is a random number generator; it returns a dictionary mapping the features to outcomes.\nuncertainty: a function of evidence; it returns the measure of variance or uncertainty about the target variable, conditioned on the experimental evidence acquired so far.\nweights: a function of evidence; it returns probabilities (posterior) acrss the rows in data.\n\nArguments\n\ndata: a dataframe with historical data.\ntarget: target column name or a vector of target columns names.\n\nKeyword Argumets\n\nuncertainty: a function that takes the subdataframe containing columns in targets along with prior, and returns an anonymous function taking a single argument (a probability vector over observations) and returns an uncertainty measure over targets.\nsimilarity: a function that, for each row, takes distances between row[col] and readout[col], and returns a non-negative probability mass for the row.\ndistance: a dictionary of pairs colname => similarity functional, where a similarity functional must implement the signature (readout, col; prior). Defaults to QuadraticDistance and DiscreteDistance for Continuous and Multiclass scitypes, respectively.\nprior: prior across rows, uniform by default.\n\nExample\n\n(; sampler, uncertainty, weights) = DistanceBased(\n    data;\n    target = \"HeartDisease\",\n    uncertainty = Entropy,\n    similarity = Exponential(; λ = 5),\n);\n\n\n\n\n\n","category":"function"},{"location":"api.html#CEEDesigns.GenerativeDesigns.QuadraticDistance","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.QuadraticDistance","text":"QuadraticDistance(; λ=1, standardize=true)\n\nThis returns an anonymous function (x, col; prior) -> λ * (x .- col).^2 / σ. If standardize is set to true, σ represents col's variance calculated in relation to prior, otherwise σ equals one.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CEEDesigns.GenerativeDesigns.DiscreteDistance","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.DiscreteDistance","text":"DiscreteDistance(; λ=1)\n\nReturn an anonymous function (x, col) -> λ * (x .== col).\n\n\n\n\n\n","category":"function"},{"location":"api.html#CEEDesigns.GenerativeDesigns.MahalanobisDistance","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.MahalanobisDistance","text":"MahalanobisDistance(; diagonal=0)\n\nReturns a function that computes Mahalanobis distance between each row of data and the evidence. For a singular covariance matrix, consider adding entries to the matrix's diagonal via the diagonal keyword.\n\nArguments\n\ndiagonal: A scalar or vector to be added to the diagonal entries of the covariance matrix.\n\nReturns\n\nIt returns a high-level function of (data, targets, prior). When called, that function will return an internal function compute_distances that takes an Evidence and computes the Mahalanobis distance based on the input data and the evidence.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CEEDesigns.GenerativeDesigns.Exponential","page":"API Documentation","title":"CEEDesigns.GenerativeDesigns.Exponential","text":"Exponential(; λ=1)\n\nReturn an anonymous function x -> exp(-λ * sum(x; init=0)).\n\n\n\n\n\n","category":"function"},{"location":"api.html#Plotting","page":"API Documentation","title":"Plotting","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"CEEDesigns.plot_front\nCEEDesigns.make_labels\nCEEDesigns.plot_evals","category":"page"},{"location":"api.html#CEEDesigns.plot_front","page":"API Documentation","title":"CEEDesigns.plot_front","text":"plot_front(designs; grad=cgrad(:Paired_12), xlabel, ylabel, labels=get_labels(designs))\n\nRender scatter plot of efficient designs, as returned from efficient_designs.\n\nYou may optionally specify a color gradient, to draw the colors from.\n\nExamples\n\ndesigns = efficient_designs(experiment, state)\nplot_front(designs)\nplot_front(designs; grad = cgrad(:Paired_12))\n\n\n\n\n\n","category":"function"},{"location":"api.html#CEEDesigns.make_labels","page":"API Documentation","title":"CEEDesigns.make_labels","text":"make_labels(designs)\n\nMake labels used plotting of experimental designs.\n\n\n\n\n\n","category":"function"},{"location":"api.html#CEEDesigns.plot_evals","page":"API Documentation","title":"CEEDesigns.plot_evals","text":"plot_evals(eval; ylabel=\"information measure\")\n\nCreate a stick plot that visualizes the performance measures evaluated for subsets of experiments.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"EditURL = \"GenerativeDesigns.jl\"","category":"page"},{"location":"tutorials/GenerativeDesigns.html#Heart-Disease-Triage-Meets-Generative-Modeling","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"","category":"section"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Consider again a situation where a group of patients is tested for a specific disease. It may be costly to conduct an experiment yielding the definitive answer; instead, we want to utilize various proxy experiments that provide partial information about the presence of the disease.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Importantly, we aim to design personalized adaptive policies for each patient. At the beginning of the triage process, we use a patient's prior data, such as sex, age, or type of chest pain, to project a range of cost-efficient experimental designs. Internally, while constructing these designs, we incorporate multiple-step-ahead lookups to model probable experimental outcomes and consider the subsequent decisions for each outcome. Then after choosing a specific decision policy from this set and acquiring additional experimental readouts, we adjust the continuation based on this evidence.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"The personalized experimental designs are motivated by the fact that the value of information collected from an experiment often differs across subsets of the entities involved in the triage process.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"(Image: information value matrix)","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In the context of static designs, where each individual from the 'Population' undergoes the same triage process, 'Experiment C' would contribute the maximum information value. On the other hand, if we have the capability to adapt the triage process specifically for 'Population 1' and 'Population 2', we would choose 'Experiment 1' and 'Experiment 2' respectively, thereby improving the value of information acquired.","category":"page"},{"location":"tutorials/GenerativeDesigns.html#Theoretical-Framework","page":"Heart Disease Triage Meets Generative Modeling","title":"Theoretical Framework","text":"","category":"section"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Let us consider a set of n experiments E =  e_1 ldots e_n, and let y denote the target variable that we want to predict.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We conceptualize the triage as a Markov decision process, in which we iteratively choose to conduct a subset of experiments S subseteq E and then, based on the experimental evidence, update our belief about the distribution of outcomes for the experiments that have not yet been conducted.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Within the framework,","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"state is modeled as the set of experiments conducted so far along with the acquired experimental evidence and accumulated costs;\nactions are subsets of experiments that have not yet been conducted; the size of these subsets is restricted by the maximum number of parallel experiments.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Importantly, the outcome of a set S of experiments is modeled as a random variable e_S, conditioned on the current state, i.e., combined evidence. This means that if in a given state outcomes from experiments in S subseteq E are available, the outcome of experiments in S subseteq E setminus S is drawn from a posterior r sim q(e_S  e_S).","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We do not claim to know the 'best' way to define the posterior q. Instead, our approach is generic and allows us to consider any generative function that takes the current state and the set of experiments to be conducted, and returns a sample drawn from the implicit, theoretical posterior of the selected experiments.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"The information value associated with the state, derived from experimental evidence, can be modeled through any statistical or information-theoretic measure such as the variance or uncertainty associated with the target variable posterior q(ye_S).","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"For example, consider EDDI: Efficient Dynamic Discovery of High-Value Information with Partial VAE, where the authors use a VAE approach to model the posterior distribution and utilize Kullback-Leibler divergence to model the information gain.","category":"page"},{"location":"tutorials/GenerativeDesigns.html#Distance-Based-Sampling-from-Historical-Data","page":"Heart Disease Triage Meets Generative Modeling","title":"Distance-Based Sampling from Historical Data","text":"","category":"section"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We implemented an approach that iteratively distributes a belief over historical entities likely to be similar to the entity currently being tested. As a result, we sample from the outputs of these historical entities, weighted by the probabilistic weight assigned by our system of belief. In doing so, we produce a specific model for q(e_S^  e_S) and q(y  e_S).","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"More specifically, consider a dataset of historical outputs across m features X = x_1 ldots x_m for l entities (with entities and features representing rows and columns, respectively). Let's denote the target variable we want to predict as y.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We assume that each experiment e in E yields readouts over a subset X_e subseteq X of features.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In what follows, we discuss the assignment of probabilistic weights w_j to each entity (or row in the dataset).","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In the initial state, when there is no experimental evidence gathered yet, we assign the weights according to a predetermined prior.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"If this is not the case, we have to compute the weights using particular distance and similarity functionals.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"For each feature xin X, we consider a function rho_x, which measures the distance between two outputs. By default, we consider:","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Rescaled Kronecker delta (i.e., rho(x y)=0 only when x=y, and rho(x y)= lambda under any other circumstances, with lambda  0) for discrete features (i.e., features whose types are modeled as MultiClass type in ScientificTypes.jl);\nRescaled squared distance rho(x y) = λ  frac(x - y)^22sigma_2, where sigma_2 is the variance of the feature column, estimated with respect to the prior for continuous features.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Therefore, given an experimental state with readouts over the feature set F subseteq X, we can calculate the total distance from the entity recorded in the j-th row as d_j = sum_xin F rho_x (hat x x_j), where hat x and x_j denote the readout for feature x for the entity being tested and the entity recorded in j-th column, respectively.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Alternatively, we could use the Mahalanobis distance.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Next, we convert distances d_j into probabilistic weights w_j. By default, we use a rescaled exponential function, i.e., we put w_j = exp(-lambda d_j) for some lambda0. Notably, lambda's value determines how belief is distributed across the historical entities. Larger values of lambda concentrate the belief tightly around the 'closest' historical entities, while smaller values distribute more belief to more distant entities.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Importantly, the proper choice of the distance functionals and the 'similarity' functional discussed above is a question of hyper-optimization.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Assuming the weights w_j have been assigned, we can sample an index hat j in  1 ldots l according to these weights. To draw a sample hat x from feature xin X, we let hat x be equal to the value in the column associated with feature x for the hat j-th row (entity). We can also take a sample from the target variable in the same way.","category":"page"},{"location":"tutorials/GenerativeDesigns.html#Objective-Sense","page":"Heart Disease Triage Meets Generative Modeling","title":"Objective Sense","text":"","category":"section"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"The reward and stopping condition of the triage process can be interpreted in various ways.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"The triage may continue until the uncertainty about the posterior distribution of the target variable falls below a certain level. Our aim is to minimize the anticipated combined monetary cost and execution time of the triage (considered as a 'negative' reward). If all experiments are conducted without reaching below the required uncertainty level, or if the maximum number of experiments is exceeded, we penalize this scenario with a 'minus infinite' reward.\nWe may aim to minimize the expected uncertainty while being constrained by the costs of the experiment.\nAlternatively, we could maximize the value of experimental evidence, adjusted for the incurred experimental costs.","category":"page"},{"location":"tutorials/GenerativeDesigns.html#Policy-Search","page":"Heart Disease Triage Meets Generative Modeling","title":"Policy Search","text":"","category":"section"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Standard MDP algorithms can be used to solve this problem (offline learning) or construct the policy (online learning) for the sequential decision-making.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Our MDP's state space is finite-dimensional but generally continuous due to the allowance of continuous features, which complicates the problem and few algorithms specialize in this area.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We used the Double Progressive Widening Algorithm for this task as detailed in A Comparison of Monte Carlo Tree Search and Mathematical Optimization for Large Scale Dynamic Resource Allocation.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In a nutshell, the Double Progressive Widening (DPW) algorithm is designed for online learning in complex environments, particularly those known as Continuous Finite-dimensional Markov Decision Processes where the state space is continuous. The key idea behind DPW is to progressively expand the search tree during the Monte Carlo Tree Search (MCTS) process. The algorithm does so by dynamically and selectively adding states and actions to the tree based on defined heuristics.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In the context of online learning, this algorithm addresses the complexity and challenges of real-time decision-making in domains with a large or infinite number of potential actions. As information is gathered in actual runtime, the algorithm explores and exploits this information to make optimal or near-optimal decisions. In other words, DPW permits the learning process to adapt on-the-fly as more data is made available, making it an effective tool for the dynamic and uncertain nature of online environments.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In particular, at the core of the Double Progressive Widening (DPW) algorithm are several key components, including expansion, search, and rollout.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"The search component is where the algorithm sifts through the search tree to determine the most promising actions or states to explore next. By using exploration-exploitation strategies, it can effectively balance its efforts between investigating previously successful actions and venturing into unexplored territories.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"The expansion phase is where the algorithm grows the search tree by adding new nodes, representing new state-action pairs, to the tree. This is done based on a predefined rule that dictates when and how much the tree should be expanded. This allows the algorithm to methodically discover and consider new potential actions without becoming overwhelmed with choices.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Lastly, the rollout stage, also known as a simulation stage, is where the algorithm plays out a series of actions to the end of a game or scenario using a specific policy (like a random policy). The results of these rollouts are then used to update the estimates of the values of state-action pairs, increasing the accuracy of future decisions.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"(Image: One iteration of the MCTS algorithm, taken from https://ieeexplore.ieee.org/document/6145622)","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In the above figure, nodes represent states of the decision process, while edges correspond to actions connecting these states.","category":"page"},{"location":"tutorials/GenerativeDesigns.html#Heart-Disease-Dataset","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Dataset","text":"","category":"section"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In this tutorial, we consider a dataset that includes 11 clinical features along with a binary variable indicating the presence of heart disease in patients. The dataset can be found at Kaggle: Heart Failure Prediction. It utilizes heart disease datasets from the UCI Machine Learning Repository.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"using CSV, DataFrames\ndata = CSV.File(\"data/heart_disease.csv\") |> DataFrame\ndata[1:10, :]","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We provide appropriate scientific types of the features.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"using ScientificTypes\n\ntypes = Dict(\n    :MaxHR => Continuous,\n    :Cholesterol => Continuous,\n    :ChestPainType => Multiclass,\n    :Oldpeak => Continuous,\n    :HeartDisease => Multiclass,\n    :Age => Continuous,\n    :ST_Slope => Multiclass,\n    :RestingECG => Multiclass,\n    :RestingBP => Continuous,\n    :Sex => Multiclass,\n    :FastingBS => Continuous,\n    :ExerciseAngina => Multiclass,\n)\ndata = coerce(data, types);\nnothing #hide","category":"page"},{"location":"tutorials/GenerativeDesigns.html#Generative-Model-for-Outcomes-Sampling","page":"Heart Disease Triage Meets Generative Modeling","title":"Generative Model for Outcomes Sampling","text":"","category":"section"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"using CEEDesigns, CEEDesigns.GenerativeDesigns","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"As previously discussed, we provide a dataset of historical records, the target variable, along with an information-theoretic measure to quantify the uncertainty about the target variable.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In what follows, we obtain three functions:","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"sampler: this is a function of (evidence, features, rng), in which evidence denotes the current experimental evidence, features represent the set of features we want to sample from, and rng is a random number generator;\nuncertainty: this is a function of evidence,\nweights: this represents a function of evidence that distributes probabilistic weights across the rows in the dataset.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Note that internally, a state of the decision process is represented as a tuple (evidence, costs).","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"You can specify the method for computing the distance using the distance keyword. By default, the Kronecker delta and quadratic distance will be utilised for categorical and continuous features, respectively.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"(; sampler, uncertainty, weights) = DistanceBased(\n    data;\n    target = \"HeartDisease\",\n    uncertainty = Entropy,\n    similarity = Exponential(; λ = 5),\n);\nnothing #hide","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Alternatively, you can provide a dictionary of feature => distance pairs. The implemented distance functionals are DiscreteDistance(; λ) and QuadraticDistance(; λ, standardize=true). In that case, the specified distance will be applied to the respective feature, after which the distances will be collated across the range of features.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"The above call is therefore equivalent to:","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"numeric_feats = filter(c -> c <: Real, eltype.(eachcol(data)))\ncategorical_feats = setdiff(names(data), numeric_feats)\n\nDistanceBased(\n    data;\n    target = \"HeartDisease\",\n    uncertainty = Entropy,\n    similarity = Exponential(; λ = 5),\n    distance = merge(\n        Dict(c => DiscreteDistance() for c in categorical_feats),\n        Dict(c => QuadraticDistance() for c in numeric_feats),\n    ),\n);\nnothing #hide","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"You can also use the Mahalanobis distance (MahalanobisDistance(; diagonal)). For example, we could write:","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"DistanceBased(\n    data[!, [\"RestingBP\", \"MaxHR\", \"Cholesterol\", \"FastingBS\", \"HeartDisease\"]]; # the Mahalanobis distance only works with numeric features, so we selected a few, along with the target variable\n    target = \"HeartDisease\",\n    uncertainty = Entropy,\n    similarity = Exponential(; λ = 5),\n    distance = MahalanobisDistance(; diagonal = 1),\n);\nnothing #hide","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"The package offers an additional flexibility by allowing an experiment to yield readouts over multiple features at the same time. In our scenario, we can consider the features RestingECG, Oldpeak, ST_Slope, and MaxHR to be obtained from a single experiment ECG.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We specify the experiments along with the associated features:","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"experiments = Dict(\n    # experiment => features\n    \"BloodPressure\" => 1.0 => [\"RestingBP\"],\n    \"ECG\" => 5.0 => [\"RestingECG\", \"Oldpeak\", \"ST_Slope\", \"MaxHR\"],\n    \"BloodCholesterol\" => 20.0 => [\"Cholesterol\"],\n    \"BloodSugar\" => 20.0 => [\"FastingBS\"],\n    \"HeartDisease\" => 100.0,\n)","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Let us inspect the distribution of belief for the following experimental evidence:","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"evidence = Evidence(\"Age\" => 55, \"Sex\" => \"M\")","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"using StatsBase: countmap\nusing Plots","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"target_belief = countmap(data[!, \"HeartDisease\"], weights(evidence))\np = bar(\n    0:1,\n    [target_belief[0], target_belief[1]];\n    xrot = 40,\n    ylabel = \"probability\",\n    color = :teal,\n    title = \"unc: $(round(uncertainty(evidence), digits=1))\",\n    kind = :bar,\n    legend = false,\n);\nxticks!(p, 0:1, [\"no disease\", \"disease\"]);\np","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Let us next add an outcome of blood pressure measurement:","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"evidence_with_bp = merge(evidence, Dict(\"RestingBP\" => 190))\n\ntarget_belief = countmap(data[!, \"HeartDisease\"], weights(evidence_with_bp))\np = bar(\n    0:1,\n    [target_belief[0], target_belief[1]];\n    xrot = 40,\n    ylabel = \"probability\",\n    color = :teal,\n    title = \"unc: $(round(uncertainty(evidence_with_bp), digits=2))\",\n    kind = :bar,\n    legend = false,\n);\nxticks!(p, 0:1, [\"no disease\", \"disease\"]);\np","category":"page"},{"location":"tutorials/GenerativeDesigns.html#Cost-Efficient-Experimental-Designs-for-Uncertainty-Reduction","page":"Heart Disease Triage Meets Generative Modeling","title":"Cost-Efficient Experimental Designs for Uncertainty Reduction","text":"","category":"section"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In this experimental setup, our objective is to minimize the expected experimental cost while ensuring the uncertainty remains below a specified threshold.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We use the provided function efficient_designs to construct the set of cost-efficient experimental designs for various levels of uncertainty threshold. In the following example, we generate 6 thresholds spaces evenly between 0 and 1, inclusive.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Internally, for each choice of the uncertainty threshold, an instance of a Markov decision problem in POMDPs.jl is created, and the POMDPs.solve is called on the problem. Afterwards, a number of simulations of the decision-making problem is run, all starting with the experimental state.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"# set seed for reproducibility\nusing Random: seed!\nseed!(1)","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"evidence = Evidence(\"Age\" => 35, \"Sex\" => \"M\")","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"# use less number of iterations to speed up build process\nsolver = GenerativeDesigns.DPWSolver(;\n    n_iterations = 20_000,\n    exploration_constant = 5.0,\n    tree_in_info = true,\n)\ndesigns = efficient_designs(\n    experiments;\n    sampler,\n    uncertainty,\n    thresholds = 6,\n    evidence,\n    solver,\n    mdp_options = (; max_parallel = 1),\n    repetitions = 5,\n);\nnothing #hide","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We plot the Pareto-efficient actions:","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"plot_front(designs; labels = make_labels(designs), ylabel = \"% uncertainty\")","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We render the search tree for the second design, sorted in descending order based on the uncertainty threshold:","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"using D3Trees\nd3tree = D3Tree(designs[2][2].tree; init_expand = 2)","category":"page"},{"location":"tutorials/GenerativeDesigns.html#Parallel-Experiments","page":"Heart Disease Triage Meets Generative Modeling","title":"Parallel Experiments","text":"","category":"section"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We may exploit parallelism in the experimental arrangement. To that end, we first specify the monetary cost and execution time for each experiment, respectively.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"experiments = Dict(\n    # experiment => (monetary cost, execution time) => features\n    \"BloodPressure\" => (1.0, 1.0) => [\"RestingBP\"],\n    \"ECG\" => (5.0, 5.0) => [\"RestingECG\", \"Oldpeak\", \"ST_Slope\", \"MaxHR\"],\n    \"BloodCholesterol\" => (20.0, 20.0) => [\"Cholesterol\"],\n    \"BloodSugar\" => (20.0, 20.0) => [\"FastingBS\"],\n    \"HeartDisease\" => (100.0, 100.0),\n)","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We have to provide the maximum number of concurrent experiments. Additionally, we can specify the tradeoff between monetary cost and execution time - in our case, we aim to minimize the execution time.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"# minimize time, two concurrent experiments at maximum\nseed!(1)\n# use less number of iterations to speed up build process\nsolver = GenerativeDesigns.DPWSolver(;\n    n_iterations = 2_000,\n    exploration_constant = 5.0,\n    tree_in_info = true,\n)\ndesigns = efficient_designs(\n    experiments;\n    sampler,\n    uncertainty,\n    thresholds = 6,\n    evidence,\n    solver,\n    mdp_options = (; max_parallel = 2, costs_tradeoff = (0, 1.0)),\n    repetitions = 5,\n);\nnothing #hide","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"We plot the Pareto-efficient actions:","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"plot_front(designs; labels = make_labels(designs), ylabel = \"% uncertainty\")","category":"page"},{"location":"tutorials/GenerativeDesigns.html#Efficient-Value-Experimental-Designs","page":"Heart Disease Triage Meets Generative Modeling","title":"Efficient Value Experimental Designs","text":"","category":"section"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In this experimental setup, we aim to maximize the value of experimental evidence, adjusted for the incurred experimental costs.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"For this purpose, we need to specify a function that quantifies the 'value' of decision-process making state, modeled as a tuple of experimental evidence and costs.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"value = function (evidence, (monetary_cost, execution_time))\n    return (1 - uncertainty(evidence)) - (0.005 * sum(monetary_cost))\nend","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"Considering a discount factor lambda, the total reward associated with the experimental state in an n-step decision process is given by r = r_1 + sum_i=2^n lambda^i-1 (r_i - r_i-1), where r_i is the value associated with the i-th state.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"In the following example, we also limit the maximum rollout horizon to 4.","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"seed!(1)\n# use less number of iterations to speed up build process\nsolver = GenerativeDesigns.DPWSolver(; n_iterations = 2_000, depth = 4, tree_in_info = true)\ndesign = efficient_value(\n    experiments;\n    sampler,\n    value,\n    evidence,\n    solver,\n    repetitions = 5,\n    mdp_options = (; discount = 0.8),\n);\nnothing #hide","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"design[1] # optimized cost-adjusted value","category":"page"},{"location":"tutorials/GenerativeDesigns.html","page":"Heart Disease Triage Meets Generative Modeling","title":"Heart Disease Triage Meets Generative Modeling","text":"d3tree = D3Tree(design[2].tree; init_expand = 2)","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"EditURL = \"StaticDesignsFiltration.jl\"","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html#Heart-Disease-Triage-With-Early-Droupout","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"","category":"section"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Consider again a situation where a group of patients is tested for a specific disease. It may be costly to conduct an experiment yielding the definitive answer. Instead, we want to utilize various proxy experiments that provide partial information about the presence of the disease.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Moreover, we may assume that for some patients, the evidence gathered from proxy experiments can be considered 'conclusive'. Effectively, some patients may not need any additional triage; they might be deemed healthy or require immediate commencement of treatment. By doing so, we could save significant resources.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html#Theoretical-Framework","page":"Heart Disease Triage With Early Droupout","title":"Theoretical Framework","text":"","category":"section"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Let us consider a set of n experiments E =  e_1 ldots e_n.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"For each subset S subseteq E of experiments, we denote by v_S the value of information acquired from conducting experiments in S.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Moreover, it can be assumed that a set of extrinsic decision-making rules is imposed on the experimental readouts. If the experimental evidence acquired for a given entity satisfies a specific criterion, that entity is then removed from the triage. However, other entities within the batch will generally continue in the experimental process. In general, the process of establishing such rules is largely dependent on the specific problem and requires comprehensive understanding of the subject area.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"We denote the expected fraction of entities that remain in the triage after conducting a set S of experiments as the filtration rate, f_S. In the context of disease triage, this can be interpreted as the fraction of patients for whom the experimental evidence does not provide a 'conclusive' result.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"In the cost-sensitive setting of CEEDesigns, conducting an experiment e incurs a cost (m_e t_e). Generally, this cost is specified in terms of monetary cost and execution time of the experiment.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"To compute the cost associated with carrying out a set of experiments S, we first need to introduce the notion of an arrangement o of the experiments S. An arrangement is modeled as a sequence of mutually disjoint subsets of S. In other words, o = (o_1 ldots o_l) for a given linmathbb N, where bigcup_i=1^l o_i = S and o_i cap o_j = emptyset for each 1leq i  j leq l.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Given a subset S of experiments and their arrangement o, the total (discounted) monetary cost and execution time of the experimental design is given as m_o = sumi=1^l r_S_i-1sum_ein o_i m_e and t_o = sum_i=1^l max  t_e  ein o_i, respectively. Importantly, the factor r_S_i-1 models the fact that a set of entities may have dropped out in the previous experiments, hence saving the resources on running the subsequent experiments.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"We note that these computations are based on the assumption that monetary cost is associated with the analysis of a single experimental entity, such as a patient. Therefore, the total monetary cost obtained for a specific arrangement is effectively the 'expected' monetary cost, adjusted for a single entity. Conversely, we suppose that all entities can be concurrently examined in a specific experiment. As such, the total execution time is equivalent to the longest time until all experiments within an arrangement are finished or all entities have been eliminated (which ocurrs when the filtration rate the experiments conducted so far is zero). Importantly, this distinctly differs from calculating the 'expected lifespan' of an entity in the triage.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"For instance, consider the experiments e_1 e_2 e_3, and e_4 with associated costs (1 1), (1 3), (1 2), and (1 4), and filtration rates 090807, and 06. For subsets of experiments, we simply assume that the filtration rates multiply, thereby treating the experiments as independent binary discriminators. In other words, the filtration rate for a set S= e_1 e_3  would equal f_S = 09 * 07 = 063.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"If we conduct experiments e_1 through e_4 in sequence, this would correspond to an arrangement o = ( e_1   e_2   e_3   e_4 ) with a total cost of m_o = 1 + 09 * 1 + 072 * 1 + 0504 * 1 = 3124 and t_o = 10.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"However, if we decide to conduct e_1 in parallel with e_3, and e_2 with e_4, we would obtain an arrangement o = ( e_1 e_3   e_2 e_4 ) with a total cost of m_o = 2 + 063 * 2 = 326, and t_o = 3 + 4 = 7.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Given the constraint on the maximum number of parallel experiments, we construct an arrangement o of experiments S such that, for a fixed tradeoff lambda between monetary cost and execution time, the expected combined cost c_(o lambda) = lambda m_o + (1-lambda) t_o is minimized. Significantly, our objective is to leverage the filtration rates within the experimental arrangement.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html#A-Note-on-Optimal-Arrangements","page":"Heart Disease Triage With Early Droupout","title":"A Note on Optimal Arrangements","text":"","category":"section"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"In situations when experiments within a set S are executed sequentially, i.e., one after the other, it can be demonstrated that the experiments should be arranged in ascending order by fraclambda m_e + (1-lambda) t_e1-f_e.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Continuing our example and assuming that the experiments are conducted sequentially, the optimal arrangement o would be to run experiments e_4 through e_1, yielding m_o = 2356.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"When we allow simultaneous execution of experiments, the problem turns more complicated, and we currently are not aware of an 'analytical' solution for it. Instead, we proposed approximating the 'optimal' arrangement as the 'optimal' policy found for a particular Markov decision process, in which:","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"state is the set of experiments that have been conducted thus far,\nactions are subsets of experiments which have not been conducted yet; the size of these subsets is restricted by the maximum number of parallel experiments;\nreward is a combined monetary cost and execution time, discounted by the filtration rate of previously conducted experiments.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Provided we know the information values v_S, filtration rates r_S, and experimental costs c_S for each subset S subseteq E, we find a collection of Pareto-efficient experimental designs that balance both the implied value of information and the experimental cost.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html#Heart-Disease-Dataset","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Dataset","text":"","category":"section"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"In this tutorial, we consider a dataset that includes 11 clinical features along with a binary variable indicating the presence of heart disease in patients. The dataset can be found at Kaggle: Heart Failure Prediction. It utilizes heart disease datasets from the UCI Machine Learning Repository.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"using CSV, DataFrames\ndata = CSV.File(\"data/heart_disease.csv\") |> DataFrame\ndata[1:10, :]","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"In order to adapt the dataset to the current context, we can assume that, for every experiment, a medical specialist determined a range for 'conclusive' and 'inconclusive' outputs. This determination could be based on, say, optimizing the precision and recall factors of the resultant discriminative model. As an example, consider A novel approach for heart disease prediction using strength scores with significant predictors where rule mining for heart disease prediction is considered.\n It should be noted that the readout ranges defined below are entirely fictional.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"inconclusive_regions = Dict(\n    \"ChestPainType\" => [\"NAP\", \"ASY\"],\n    \"RestingBP\" => (50, 150),\n    \"ExerciseAngina\" => [\"N\"],\n    \"FastingBS\" => [0],\n    \"RestingECG\" => [\"Normal\"],\n    \"MaxHR\" => (50, 120),\n    \"Cholesterol\" => (0, 240),\n    \"Oldpeak\" => (-2.55, 2.55),\n)","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"We apply the rules to derive a binary dataset where 'true' signifies that the readout was inconclusive, requiring them to remain in the triage.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"data_binary = DataFrame();\nfor colname in names(data[!, Not(\"HeartDisease\")])\n    if haskey(inconclusive_regions, colname)\n        if inconclusive_regions[colname] isa Vector\n            data_binary[!, colname] =\n                map(x -> x ∈ inconclusive_regions[colname], data[!, colname])\n        else\n            lb, ub = inconclusive_regions[colname]\n            data_binary[!, colname] = map(x -> lb <= x <= ub, data[!, colname])\n        end\n    else\n        data_binary[!, colname] = trues(nrow(data))\n    end\nend\n\ndata_binary[1:10, :]","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html#Discriminative-Power-and-Filtration-Rates","page":"Heart Disease Triage With Early Droupout","title":"Discriminative Power and Filtration Rates","text":"","category":"section"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"In this scenario, we model the value of information v_S acquired by conducting a set of experiments as the ratio of patients for whom the results across the experiments in S were 'inconclusive', i.e., cap_ein S textpatient  textinconclusive in  e   textpatients. Essentially, the very same measure is used here to estimate the filtration rate.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"The CEEDesigns package offers an additional flexibility by allowing an experiment to yield readouts over multiple features at the same time. In our scenario, we can consider the features RestingECG, Oldpeak, ST_Slope, and MaxHR to be obtained from a single experiment ECG.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"We specify the experiments along with the associated features:","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"experiments = Dict(\n    # experiment => features\n    \"BloodPressure\" => [\"RestingBP\"],\n    \"ECG\" => [\"RestingECG\", \"Oldpeak\", \"ST_Slope\", \"MaxHR\"],\n    \"BloodCholesterol\" => [\"Cholesterol\"],\n    \"BloodSugar\" => [\"FastingBS\"],\n)","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"We may also provide additional zero-cost features, which are always available.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"zero_cost_features = [\"Age\", \"Sex\", \"ChestPainType\", \"ExerciseAngina\"]","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"For binary datasets, we may use evaluate_experiments from CEEDesigns.StaticDesigns to evaluate the discriminative power of subsets of experiments.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"using CEEDesigns, CEEDesigns.StaticDesigns","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"perf_eval = evaluate_experiments(experiments, data_binary; zero_cost_features)","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Note that for each subset of experiments, the function returns a named tuple with fields loss and filtration.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"We plot discriminative power evaluated for subsets of experiments.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"plot_evals(perf_eval; ylabel = \"discriminative power\")","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html#Cost-Efficient-Designs","page":"Heart Disease Triage With Early Droupout","title":"Cost-Efficient Designs","text":"","category":"section"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"We specify the cost associated with the execution of each experiment.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"costs = Dict(\n    # experiment => cost\n    \"BloodPressure\" => 1,\n    \"ECG\" => 5,\n    \"BloodCholesterol\" => 20,\n    \"BloodSugar\" => 20,\n)","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"We use the provided function efficient_designs to construct the set of cost-efficient experimental designs. Note that the filtration is enabled implicitly since we provided the filtration rates within perf_eval. Another form of perf_eval would be subset of experiments => information measure, in which case the filtration would equal one. That is, no dropout would be considered.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"designs = efficient_designs(costs, perf_eval)","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"plot_front(designs; labels = make_labels(designs), ylabel = \"discriminative power\")","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Let us compare the above with the efficient front with disabled filtration.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"# pass performance eval with discarded filtration rates (defaults to 1)\ndesigns_no_filtration = efficient_designs(costs, Dict(k => v.loss for (k, v) in perf_eval))","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"using Plots\np = scatter(\n    map(x -> x[1][1], designs_no_filtration),\n    map(x -> x[1][2], designs_no_filtration);\n    label = \"designs with filtration disabled\",\n    c = :blue,\n    mscolor = nothing,\n    fontsize = 16,\n)\nscatter!(\n    p,\n    map(x -> x[1][1], designs),\n    map(x -> x[1][2], designs);\n    xlabel = \"combined cost\",\n    ylabel = \"discriminative power\",\n    label = \"designs with filtration enabled\",\n    c = :teal,\n    mscolor = nothing,\n    fontsize = 16,\n)","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html#Arrangement-of-a-Set-of-Experiments","page":"Heart Disease Triage With Early Droupout","title":"Arrangement of a Set of Experiments","text":"","category":"section"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Importantly, the total execution cost of an experiment is generally not the sum of costs associated to each individual experiment. In fact, a non-zero dropout rate (filtration < 1) discounts the expected cost of subsequent experiments. As discussed previously, we are not aware of an 'analytical' solution to this problem.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Instead, we approximate the 'optimal' arrangement as the 'optimal' policy for a particular Markov decision process. This can be accomplished using, for instance, the Monte Carlo Tree Search algorithm as implemented in the POMDPs.jl package.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"The following is a visualisation of the DPW search tree that was used to find an optimal arrangement for a set of experiments yielding the highest information value.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"using MCTS, D3Trees\n\nexperiments = Set(vcat.(designs[end][2].arrangement...)[1])\n(; planner) = CEEDesigns.StaticDesigns.optimal_arrangement(\n    costs,\n    perf_eval,\n    experiments;\n    mdp_kwargs = (; tree_in_info = true),\n)\n_, info = action_info(planner, Set{String}())\n\nt = D3Tree(info[:tree]; init_expand = 2)","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"plot_front(designs; labels = make_labels(designs), ylabel = \"discriminative power\")","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html#Parallel-Experiments","page":"Heart Disease Triage With Early Droupout","title":"Parallel Experiments","text":"","category":"section"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"We may exploit parallelism in the experimental arrangement. To that end, we first specify the monetary cost and execution time for each experiment, respectively.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"experiments_costs = Dict(\n    # experiment => (monetary cost, execution time) => features\n    \"BloodPressure\" => (1.0, 1.0) => [\"RestingBP\"],\n    \"ECG\" => (5.0, 5.0) => [\"RestingECG\", \"Oldpeak\", \"ST_Slope\", \"MaxHR\"],\n    \"BloodCholesterol\" => (20.0, 20.0) => [\"Cholesterol\"],\n    \"BloodSugar\" => (20.0, 20.0) => [\"FastingBS\"],\n)","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"We provide the maximum number of concurrent experiments. Additionally, we specify the tradeoff between monetary cost and execution time - in our case, we aim to minimize the execution time.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"Below, we demonstrate the flexibility of efficient_designs as it can both evaluate the performance of experiments and generate efficient designs. Internally, evaluate_experiments is called first, followed by efficient_designs. Keyword arguments to the respective functions has to wrapped in eval_options and arrangement_options named tuples, respectively.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"# Implicit, calculates accuracies automatically\ndesigns = efficient_designs(\n    experiments_costs,\n    data_binary;\n    eval_options = (; zero_cost_features),\n    arrangement_options = (; max_parallel = 2, tradeoff = (0.0, 1)),\n)","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"As we can see, the algorithm correctly suggests running experiments in parallel.","category":"page"},{"location":"tutorials/StaticDesignsFiltration.html","page":"Heart Disease Triage With Early Droupout","title":"Heart Disease Triage With Early Droupout","text":"plot_front(designs; labels = make_labels(designs), ylabel = \"discriminative power\")","category":"page"},{"location":"index.html#CEEDesigns.jl:-Overview","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"","category":"section"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"A decision-making framework for the cost-efficient design of experiments, balancing the value of acquired experimental evidence and incurred costs. We have considered two different experimental setups, which are outlined below.","category":"page"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"<a><img src=\"assets/front_static.png\" align=\"right\" alt=\"code\" width=\"400\"></a>","category":"page"},{"location":"index.html#Static-experimental-designs","page":"CEEDesigns.jl: Overview","title":"Static experimental designs","text":"","category":"section"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"Here we assume that the same experimental design will be used for a population of examined entities, hence the word 'static'.","category":"page"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"For each subset of experiments, we consider an estimate of the value of acquired information. To give an example, if a set of experiments is used to predict the value of a specific target variable, our framework can leverage a built-in integration with MLJ.jl to estimate predictive accuracies of machine learning models fitted over subset of experimental features.","category":"page"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"In the cost-sensitive setting of CEEDesigns, a user provides the monetary cost and execution time of each experiment. Given the constraint on the maximum number of parallel experiments along with a fixed tradeoff between monetary cost and execution time, we devise an arrangement of each subset of experiments such that the expected combined cost is minimized.","category":"page"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"Assuming the information values and optimized experimental costs for each subset of experiments, we then generate a set of cost-efficient experimental designs.","category":"page"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"<a><img src=\"assets/front_generative.png\" align=\"right\" alt=\"code\" width=\"400\"></a>","category":"page"},{"location":"index.html#Generative-experimental-designs","page":"CEEDesigns.jl: Overview","title":"Generative experimental designs","text":"","category":"section"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"We consider 'personalized' experimental designs that dynamically adjust based on the evidence gathered from the experiments. This approach is motivated by the fact that the value of information collected from an experiment generally differs across subpopulations of the entities involved in the triage process.","category":"page"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"At the beginning of the triage process, an entity's prior data is used to project a range of cost-efficient experimental designs. Internally, while constructing these designs, we incorporate multiple-step-ahead lookups to model likely experimental outcomes and consider the subsequent decisions for each outcome. Then after choosing a specific decision policy from this set and acquiring additional experimental readouts (sampled from a generative model, hence the word 'generative'), we adjust the continuation based on this evidence.","category":"page"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"<a><img src=\"assets/search_tree.png\" align=\"left\" alt=\"code\" width=\"400\"></a>","category":"page"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"We conceptualized the triage as a Markov decision process, in which we iteratively choose to conduct a subset of experiments and then, based on the experimental evidence, update our belief about the distribution of outcomes for the experiments that have not yet been conducted. The information value associated with the state, derived from experimental evidence, can be modeled through any statistical or information-theoretic measure such as the variance or uncertainty associated with the target variable posterior.","category":"page"},{"location":"index.html","page":"CEEDesigns.jl: Overview","title":"CEEDesigns.jl: Overview","text":"We implemented the following two variants of the decision-making process: Firstly, assuming that the decision-making process only terminates when the uncertainty drops below a given threshold, we minimize the expected resource spend. Secondly, we can optimize the value of experimental evidence, adjusted for the incurred experimental costs.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"EditURL = \"StaticDesigns.jl\"","category":"page"},{"location":"tutorials/StaticDesigns.html#Heart-Disease-Triage","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"","category":"section"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Consider a situation where a group of patients is tested for a specific disease. It may be costly to conduct an experiment yielding the definitive answer. Instead, we want to utilize various proxy experiments that provide partial information about the presence of the disease.","category":"page"},{"location":"tutorials/StaticDesigns.html#Theoretical-Framework","page":"Heart Disease Triage","title":"Theoretical Framework","text":"","category":"section"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Let us consider a set of n experiments E =  e_1 ldots e_n.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"For each subset S subseteq E of experiments, we denote by v_S the value of information acquired from conducting experiments in S.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"In the cost-sensitive setting of CEEDesigns, conducting an experiment e incurs a cost (m_e t_e). Generally, this cost is specified in terms of monetary cost and execution time of the experiment.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"To compute the cost associated with carrying out a set of experiments S, we first need to introduce the notion of an arrangement o of the experiments S. An arrangement is modeled as a sequence of mutually disjoint subsets of S. In other words, o = (o_1 ldots o_l) for a given linmathbb N, where bigcup_i=1^l o_i = S and o_i cap o_j = emptyset for each 1leq i  j leq l.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Given a subset S of experiments and their arrangement o, the total monetary cost and execution time of the experimental design is given as m_o = sum_ein S m_e and t_o = sum_i=1^l max  t_e  ein o_i, respectively.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"For instance, consider the experiments e_1 e_2 e_3, and e_4 with associated costs (1 1), (1 3), (1 2), and (1 4). If we conduct experiments e_1 through e_4 in sequence, this would correspond to an arrangement o = ( e_1   e_2   e_3   e_4 ) with a total cost of m_o = 4 and t_o = 10.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"However, if we decide to conduct e_1 in parallel with e_3, and e_2 with e_4, we would obtain an arrangement o = ( e_1 e_3   e_2 e_4 ) with a total cost of m_o = 4, and t_o = 3 + 4 = 7.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Given the constraint on the maximum number of parallel experiments, we devise an arrangement o of experiments S such that, for a fixed tradeoff between monetary cost and execution time, the expected combined cost c_(o lambda) = lambda m_o + (1-lambda) t_o is minimized (i.e., the execution time is minimized).","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"In fact, it can be readily demonstrated that the optimal arrangement can be found by ordering the experiments in set S in descending order according to their execution times. Consequently, the experiments are grouped sequentially into sets whose size equals the maximum number of parallel experiments, except possibly for the final set.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Continuing our example and assuming a maximum of two parallel experiments, the optimal arrangement is to conduct e_1 in parallel with e_2, and e_3 with e_4. This results in an arrangement o = ( e_1 e_2   e_3 e_4 ) with a total cost of m_o = 4 and t_o = 2 + 4 = 6.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Assuming the information values v_S and optimized experimental costs c_S for each subset S subseteq E of experiments, we then generate a set of cost-efficient experimental designs.","category":"page"},{"location":"tutorials/StaticDesigns.html#Application-to-Predictive-Modeling","page":"Heart Disease Triage","title":"Application to Predictive Modeling","text":"","category":"section"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Consider a dataset of historical readouts over m features X = x_1 ldots x_m, and let y denote the target variable that we want to predict.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We assume that each experiment e in E yields readouts over a subset X_e subseteq X of features.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Then, for each subset S subseteq E of experiments, we may model the value of information acquired by conducting the experiments in S as the accuracy of a predictive model that predicts the value of y based on readouts over features in X_S = bigcup_ein S X_e.","category":"page"},{"location":"tutorials/StaticDesigns.html#Heart-Disease-Dataset","page":"Heart Disease Triage","title":"Heart Disease Dataset","text":"","category":"section"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"In this tutorial, we consider a dataset that includes 11 clinical features along with a binary variable indicating the presence of heart disease in patients. The dataset can be found at Kaggle: Heart Failure Prediction. It utilizes heart disease datasets from the UCI Machine Learning Repository.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"using CSV, DataFrames\ndata = CSV.File(\"data/heart_disease.csv\") |> DataFrame\ndata[1:10, :]","category":"page"},{"location":"tutorials/StaticDesigns.html#Predictive-Accuracy","page":"Heart Disease Triage","title":"Predictive Accuracy","text":"","category":"section"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"The CEEDesigns package offers an additional flexibility by allowing an experiment to yield readouts over multiple features at the same time. In our scenario, we can consider the features RestingECG, Oldpeak, ST_Slope, and MaxHR to be obtained from a single experiment ECG.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We specify the experiments along with the associated features:","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"experiments = Dict(\n    # experiment => features\n    \"BloodPressure\" => [\"RestingBP\"],\n    \"ECG\" => [\"RestingECG\", \"Oldpeak\", \"ST_Slope\", \"MaxHR\"],\n    \"BloodCholesterol\" => [\"Cholesterol\"],\n    \"BloodSugar\" => [\"FastingBS\"],\n)","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We may also provide additional zero-cost features, which are always available.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"zero_cost_features = [\"Age\", \"Sex\", \"ChestPainType\", \"ExerciseAngina\"]","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"And we specify the target for prediction.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"target = \"HeartDisease\"","category":"page"},{"location":"tutorials/StaticDesigns.html#Classifier","page":"Heart Disease Triage","title":"Classifier","text":"","category":"section"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We use MLJ.jl to evaluate the predictive accuracy over subsets of experimental features.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"using MLJ\nimport BetaML, MLJModels\nusing Random: seed!","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We provide appropriate scientific types of the features.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"types = Dict(\n    :ChestPainType => Multiclass,\n    :Oldpeak => Continuous,\n    :HeartDisease => Multiclass,\n    :Age => Continuous,\n    :ST_Slope => Multiclass,\n    :RestingECG => Multiclass,\n    :RestingBP => Continuous,\n    :Sex => Multiclass,\n    :FastingBS => Continuous,\n    :ExerciseAngina => Multiclass,\n)\ndata = coerce(data, types);\nnothing #hide","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Next, we choose a particular predictive model that will evaluated in the sequel. We can list all models that are compatible with our dataset:","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"models(matching(data, data[:, \"HeartDisease\"]))","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Eventually, we fix RandomForestClassifier from BetaML","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"classifier = @load RandomForestClassifier pkg = BetaML verbosity = 3\nmodel = classifier(; n_trees = 20, max_depth = 10)","category":"page"},{"location":"tutorials/StaticDesigns.html#Performance-Evaluation","page":"Heart Disease Triage","title":"Performance Evaluation","text":"","category":"section"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We use evaluate_experiments from CEEDesigns.StaticDesigns to evaluate the predictive accuracy over subsets of experiments. We use LogLoss as a measure of accuracy. It is possible to pass additional keyword arguments, which will be passed to MLJ.evaluate (such as measure, shown below).","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"using CEEDesigns, CEEDesigns.StaticDesigns","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"seed!(1) # evaluation process generally is not deterministic\nperf_eval = evaluate_experiments(\n    experiments,\n    model,\n    data[!, Not(\"HeartDisease\")],\n    data[!, \"HeartDisease\"];\n    zero_cost_features,\n    measure = LogLoss(),\n)","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We plot performance measures evaluated for subsets of experiments.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"plot_evals(perf_eval; ylabel = \"logloss\")","category":"page"},{"location":"tutorials/StaticDesigns.html#Cost-Efficient-Designs","page":"Heart Disease Triage","title":"Cost-Efficient Designs","text":"","category":"section"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We specify the cost associated with the execution of each experiment.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"costs = Dict(\n    # experiment => cost\n    \"BloodPressure\" => 1,\n    \"ECG\" => 5,\n    \"BloodCholesterol\" => 20,\n    \"BloodSugar\" => 20,\n)","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We use the provided function efficient_designs to construct the set of cost-efficient experimental designs.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"designs = efficient_designs(costs, perf_eval)","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"plot_front(designs; labels = make_labels(designs), ylabel = \"logloss\")","category":"page"},{"location":"tutorials/StaticDesigns.html#Parallel-Experiments","page":"Heart Disease Triage","title":"Parallel Experiments","text":"","category":"section"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We may exploit parallelism in the experimental arrangement. To that end, we first specify the monetary cost and execution time for each experiment, respectively.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"experiments_costs = Dict(\n    # experiment => (monetary cost, execution time) => features\n    \"BloodPressure\" => (1.0, 1.0) => [\"RestingBP\"],\n    \"ECG\" => (5.0, 5.0) => [\"RestingECG\", \"Oldpeak\", \"ST_Slope\", \"MaxHR\"],\n    \"BloodCholesterol\" => (20.0, 20.0) => [\"Cholesterol\"],\n    \"BloodSugar\" => (20.0, 20.0) => [\"FastingBS\"],\n)","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"We set the maximum number of concurrent experiments. Additionally, we can specify the tradeoff between monetary cost and execution time - in our case, we aim to minimize the execution time.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"Below, we demonstrate the flexibility of efficient_designs as it can both evaluate the performance of experiments and generate efficient designs. Internally, evaluate_experiments is called first, followed by efficient_designs. Keyword arguments to the respective functions has to wrapped in eval_options and arrangement_options named tuples, respectively.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"# Implicit, calculates accuracies automatically.\nseed!(1) # evaluation process generally is not deterministic\ndesigns = efficient_designs(\n    experiments_costs,\n    model,\n    data[!, Not(\"HeartDisease\")],\n    data[!, \"HeartDisease\"];\n    eval_options = (; zero_cost_features, measure = LogLoss()),\n    arrangement_options = (; max_parallel = 2, tradeoff = (0.0, 1)),\n)","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"As we can see, the algorithm correctly suggests running experiments in parallel.","category":"page"},{"location":"tutorials/StaticDesigns.html","page":"Heart Disease Triage","title":"Heart Disease Triage","text":"plot_front(designs; labels = make_labels(designs), ylabel = \"logloss\")","category":"page"}]
}
